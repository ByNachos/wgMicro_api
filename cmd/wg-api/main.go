package main

import (
	"log" // Standard log for initial messages before config and logger are fully set up.

	"wgMicro_api/internal/config"     // Application configuration loading.
	"wgMicro_api/internal/handler"    // HTTP request handlers.
	"wgMicro_api/internal/logger"     // Global Zap logger initialization.
	"wgMicro_api/internal/repository" // WireGuard data access layer.
	"wgMicro_api/internal/server"     // Gin router and server setup.
	"wgMicro_api/internal/serverkeys"
	"wgMicro_api/internal/service" // Business logic layer.

	//神父 _ "github.com/joho/godotenv" // godotenv is loaded by the config package. Keep blank import if other indirect uses.
	// No, config.LoadConfig() calls godotenv.Load() so it's a direct dependency of config package.
	// If no other package uses godotenv directly in main or its direct imports, it can be removed from here
	// and will be solely managed by the config package's go.mod entry if it were a separate module,
	// or by the main module's go.mod as an indirect dependency of the config code.
	// For now, the config package directly uses it.

	swaggerFiles "github.com/swaggo/files"     // Swagger UI files.
	ginSwagger "github.com/swaggo/gin-swagger" // Gin middleware for Swagger UI.
	"go.uber.org/zap"

	// _ "wgMicro_api/docs" // docs is generated by Swag CLI and usually imported for its init() side effect.
	// It should be imported if `swag init` was run and it registers swagger spec.
	// Based on your docs/docs.go, it has an init() that calls swag.Register. So it's needed.
	_ "wgMicro_api/docs"
)

// @title WireGuard API Service
// @version 1.0
// @description Manages WireGuard peer configurations via an HTTP API.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /

// @schemes http https

// main is the entry point for the WireGuard API service.
// It initializes configuration, logger, repository, service, handler, and router,
// then starts the HTTP server.
func main() {
	// 1. Load application configuration
	appConfig := config.LoadConfig() // appConfig теперь содержит AppEnv

	// 2. Initialize the global Zap logger
	// Передаем результат appConfig.IsDevelopment() в logger.Init
	logger.Init("", appConfig.IsDevelopment())
	defer func() {
		if err := logger.Logger.Sync(); err != nil {
			log.Printf("FATAL: Failed to sync zap logger: %v\n", err)
		}
	}()
	logger.Logger.Info("Application starting...",
		zap.String("version", "1.0"),
		zap.String("environment", appConfig.AppEnv), // Логируем текущее окружение
	)

	// 3. Initialize the ServerKeyManager to load server's own keys from wg0.conf
	// The KeyGenTimeout from appConfig can be used for the 'wg pubkey' command within ServerKeyManager
	skm, err := serverkeys.NewServerKeyManager(appConfig.WGConfigPath, appConfig.KeyGenTimeout)
	if err != nil {
		logger.Logger.Fatal("Failed to initialize ServerKeyManager",
			zap.String("wgConfigPath", appConfig.WGConfigPath),
			zap.Error(err))
	}
	serverPubKey, _ := skm.GetServerPublicKey() // Error already handled by NewServerKeyManager if keys aren't loaded
	// serverPrivKey, _ := skm.GetServerPrivateKey() // We might not need to pass private key to service if service doesn't use it directly

	logger.Logger.Info("Server keys loaded/derived successfully", zap.String("serverPublicKey", serverPubKey))

	// 4. Initialize the WireGuard repository
	repo := repository.NewWGRepository(appConfig.WGInterface, appConfig.WgCmdTimeout)

	// 5. Initialize the service layer
	// ConfigService will now take server's public key directly.
	// It no longer needs server's private key directly for its current operations,
	// unless a future feature specifically requires the service to have it.
	// The ServerEndpoint is still from appConfig. KeyGenTimeout is also from appConfig (for client key gen).
	svc := service.NewConfigService(
		repo,
		serverPubKey, // Pass the loaded server public key
		// serverPrivKey, // Pass server private key IF service methods explicitly need it. For now, BuildClientConfig needs server's pubkey.
		appConfig.ServerEndpoint,
		appConfig.KeyGenTimeout,
	)

	// 6. Initialize the HTTP handler layer
	cfgHandler := handler.NewConfigHandler(svc)

	// 7. Setup the Gin router
	// The router.GET for swagger might need docs.SwaggerInfo.Host updated if port is dynamic
	// docs.SwaggerInfo.Host = fmt.Sprintf("localhost:%s", appConfig.Port) // Example
	router := server.NewRouter(cfgHandler, repo)

	// 8. Setup Swagger UI endpoint
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	logger.Logger.Info("Swagger UI available at /swagger/index.html")

	// 9. Start the HTTP server
	serverAddress := ":" + appConfig.Port
	logger.Logger.Info("Starting HTTP server...",
		zap.String("address", "http://localhost"+serverAddress),
		zap.String("port", appConfig.Port),
	)

	if err := router.Run(serverAddress); err != nil {
		logger.Logger.Fatal("Failed to start HTTP server",
			zap.String("address", serverAddress),
			zap.Error(err),
		)
	}
}
